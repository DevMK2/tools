#!/usr/bin/python

from flask import Flask, render_template, jsonify, request
from werkzeug import secure_filename
import linuxcnc
import hal
import os
import signal
import sys
import threading, time
import subprocess
import argparse
import logging
from time import strftime
import uwsgi
import json

from ctypes import *

import rs274.glcanon
import rs274.interpret
import gcode

import re
import tempfile
import shutil
import copy
from minigl import *
import xml.etree.ElementTree as elemTree

parser = argparse.ArgumentParser(description='linuxcnc\'s webui daemon')
parser.add_argument('-ini', dest='inifile')
parser.add_argument('-dev', dest='dev', action='store_true')
parser.add_argument('-pmac', dest='pmac', action='store_true')
parser.add_argument('-cnc', dest='cnc', action='store_true')
args = parser.parse_args()

if args.dev:
    webdPath = os.path.dirname(os.path.abspath(__file__))
    sys.path.append('/'.join([webdPath, "apply"]))
    sys.path.append('/'.join([webdPath, "pmacShell"]))
    sys.path.append('/'.join([webdPath, "ethercat_config"]))
else:
    sys.path.append("/usr/lib/python2.7/dist-packages/webui/apply")
    sys.path.append("/usr/lib/python2.7/dist-packages/webui/pmacShell")
    sys.path.append("/usr/lib/python2.7/dist-packages/webui/ethercat_config")

from apply import apply
from pmacClient import PMACClient
import ethercat_config
ethercat_config.openEtherCAT()

if args.dev:
    app = Flask(__name__)
else:
    app = Flask(__name__, template_folder='/usr/share/linuxcnc-webui/templates', static_folder='/usr/share/linuxcnc-webui/static')

log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

emc = linuxcnc
emc_stat = emc.stat()
emc_command = emc.command()
emc_error = emc.error_channel()

inipath = args.inifile
ini = linuxcnc.ini(inipath)
ini_dir = os.path.dirname(os.path.abspath(inipath))
#program_path = os.environ['LINUXCNC_NCFILES_DIR']
program_path = os.path.join(ini_dir, 'programs')
json_path = ini_dir + '/GUIethercat.json'
topology_path = ini_dir + '/graph.svg'
axes_list = ini.find('TRAJ', 'COORDINATES').split()
parameter = ini.find("RS274NGC", "PARAMETER_FILE")
parameter_path = os.path.join(ini_dir, os.path.basename(parameter or "rs274ngc.var"))
xmlfile = ''
halfile = ''
for i in ini.findall('HAL', 'HALFILE'):
    with open(os.path.join(ini_dir, i), 'r') as f:
        lines = f.readlines()

    if '# This file is generated by Janus WebD. #' == lines[0].rstrip():
        halfile = os.path.join(ini_dir, i)
    
    else:
        for line in lines:
            if 'lcec_conf' in line:
                xmlfile = os.path.join(ini_dir, line.split(' ')[-1].rstrip())

if args.cnc:

    max_feedrate = ini.find('DISPLAY', 'MAX_FEED_OVERRIDE')
    max_spindlerate = ini.find('DISPLAY', 'MAX_SPINDLE_OVERRIDE')
    limit_velocity = ini.find('DISPLAY', 'MAX_LINEAR_VELOCITY')
    linear_units = ini.find('TRAJ', 'LINEAR_UNITS')
    max_axes = ini.find('TRAJ', 'AXES')
    postgui_halfile = ini.find("HAL", "POSTGUI_HALFILE")
    ygmode = ini.find('EMC', 'MODE')

    halcomp = hal.component("webui")
    halcomp.newpin("blow", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("vacuum", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("touch", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("dressef", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("dresseb", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("dseal", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("zcyl1", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("zcyl2", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("ygclamp", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("zclamp", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("fourR", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("ygmode", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("test", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog0-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog1-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog2-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog3-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog4-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog-scale", hal.HAL_FLOAT, hal.HAL_OUT)
    halcomp.newpin("jog-x", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-y", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-z", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-c", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-d", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-count-latest", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("H1.pressure", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("H2.pressure", hal.HAL_S32, hal.HAL_OUT)
    if ini.find('DISPLAY','MAIN_PRESSURE') :
        halcomp['H1.pressure'] = int(ini.find('DISPLAY','MAIN_PRESSURE'))
    else :
        halcomp['H1.pressure'] = 0
    
    if ini.find('DISPLAY','SUB_PRESSURE') :
        halcomp['H2.pressure'] = int(ini.find('DISPLAY','SUB_PRESSURE'))
    else :
        halcomp['H2.pressure'] = 0

    for i in range(9):
        t = ini.find('AXIS_' + str(i), 'TYPE')
        halcomp.newpin("axis.%d.load" % i, hal.HAL_S32, hal.HAL_IN)
        halcomp.newpin("axis.%d.limit-load" % i, hal.HAL_U32, hal.HAL_IN)
        if t == 'ANGULAR':
            halcomp.newpin("axis.%d.srv-rpm" % i, hal.HAL_FLOAT, hal.HAL_IN)

    if postgui_halfile:
        if postgui_halfile.lower().endswith('.tcl'):
            res = os.spawnvp(os.P_WAIT, "haltcl", ["haltcl", "-i", inipath, postgui_halfile])
        else:
            res = os.spawnvp(os.P_WAIT, "halcmd", ["halcmd", "-i", inipath, "-f", postgui_halfile])
        if res: 
            raise SystemExit, res

        halcomp.ready()

    axes = []
    for i in range(int(max_axes)):
        mv = ini.find('AXIS_' + str(i), 'MAX_VELOCITY')
        axes.append({'max_velocity':float(mv)})

    units = 1 if linear_units == 'mm' else 0.0393701



elif args.pmac:
    pmac_online = PMACClient()
    max_feedrate = ini.find('DISPLAY', 'MAX_FEED_OVERRIDE')
    limit_velocity = ini.find('TRAJ', 'MAX_LINEAR_VELOCITY')
    linear_units = ini.find('TRAJ', 'LINEAR_UNITS')
    max_axes = ini.find('TRAJ', 'AXES')
    postgui_halfile = ini.find("HAL", "POSTGUI_HALFILE")

    halcomp = hal.component("webui")
    halcomp.newpin("jog0-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog1-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog2-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog3-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog4-wheel", hal.HAL_S32, hal.HAL_OUT)
    halcomp.newpin("jog-scale", hal.HAL_FLOAT, hal.HAL_OUT)
    halcomp.newpin("jog-x", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-y", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-z", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-c", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-d", hal.HAL_BIT, hal.HAL_OUT)
    halcomp.newpin("jog-count-latest", hal.HAL_S32, hal.HAL_OUT)

    if postgui_halfile:
        if postgui_halfile.lower().endswith('.tcl'):
            res = os.spawnvp(os.P_WAIT, "haltcl", ["haltcl", "-i", inipath, postgui_halfile])
        else:
            res = os.spawnvp(os.P_WAIT, "halcmd", ["halcmd", "-i", inipath, "-f", postgui_halfile])
        if res: 
            raise SystemExit, res

        halcomp.ready()

    axes = []

    for i in range(int(max_axes)):
        mv = ini.find('AXIS_' + str(i), 'MAX_VELOCITY')
        axes.append({'max_velocity':float(mv)})

    units = 1 if linear_units == 'mm' else 0.0393701

def running(s, do_poll=True):
    if do_poll:
        s.poll()
    return s.task_mode == emc.MODE_AUTO and \
        s.interp_state != emc.INTERP_IDLE

def ensure_mode(s, c, *modes):
    s.poll()
    if not modes:
        return False
    if s.task_mode in modes:
        return True
    if running(s, do_poll=False):
        return False
    c.mode(modes[0])
    c.wait_complete()
    return True

def get_variable(param_file):
    try:
        with open(param_file) as f:
            d = dict()
            for line in f:
                idx, val = line.split()
                d[int(idx)] = float(val)
        return d
    except IOError:
        return {}

def is_homed():
    homed = True
    for i, h in enumerate(emc_stat.homed):
        if emc_stat.axis_mask & (1<<i):
            homed = homed and h
    return homed

page_direction = 'program'

@app.route('/')
def index():
    if args.cnc:
        return render_template('CNCindex.html')
    elif args.pmac:
        return render_template('pmacIndex.html')

@app.route('/plot/mode')
def send_plot_mode():
    plot_mode = ini.find('DISPLAY','WEBUI_PLOT')
    if plot_mode == None:
        plot_mode ='CNC' 
    elif plot_mode == 'lms':
        plot_mode ='LMS'
    return plot_mode


##################################################################################
#                                     CNC                                        #
##################################################################################

@app.route('/cnc/stat')
def cnc_stat():
    d = {}
    emc_stat.poll()

    for i in [
            # stat
            'state',
            # task
            'task_mode', 'task_state', 'exec_state', 'interp_state',
            'read_line', 'motion_line', 'current_line', 'file',
            'command', 'program_units', 'interpreter_errcode', 'optional_stop',
            'block_delete', 'task_paused', 'input_timeout', 'rotation_xy',
            'delay_left', 'queued_mdi_commands', 
            # EMC_TRAJ_STAT traj
            'linear_units', 'angular_units',
            'cycle_time', 'axis_mask', 'motion_mode',
            'spindle_speed', 'spindlerate', 'spindle_direction',
            'enabled', 'inpos', 'queue', 'active_queue', 'queue_full', 'id',
            'paused', 'feedrate', 'rapidrate', 'velocity', 'acceleration',
            'max_velocity', 'max_acceleration', 'probe_tripped', 'probing',
            'probe_val', 'kinematics_type', 'motion_type', 'distance_to_go',
            'current_vel', 'feed_override_enabled', 'adaptive_feed_enabled',
            'feed_hold_enabled',
            # EMC_TOOL_STAT io.tool
            'pocket_prepped', 'tool_in_spindle',
            # EMC_COOLANT_STAT io.cooland
            'mist', 'flood',
            # EMC_AUX_STAT     io.aux
            'estop',
            # EMC_LUBE_STAT    io.lube
            'lube', 'lube_level', 'debug'
            ]:
        d[i] = getattr(emc_stat, i)
    d['position'] = emc_stat.position
    d['actual_position'] = emc_stat.actual_position
    d['g5x_offset'] = emc_stat.g5x_offset
    d['tool_offset'] = emc_stat.tool_offset
    d['g5x_index'] = emc_stat.g5x_index
    d['linear_units'] = emc_stat.linear_units
    d['servo_on'] = emc_stat.axis_enabled

    d['program_path'] = program_path

    d['max_feedrate'] = max_feedrate
    d['max_spindlerate'] = max_spindlerate
    d['limit_velocity'] = limit_velocity
    d['axes'] = axes
    d['ygmode'] = ygmode

    d['hal'] = {'blow': halcomp['blow'], 'vacuum': halcomp['vacuum'], 'axis':[], 'touch' : halcomp['touch'], 
    'dresser': halcomp['dressef'] & (not halcomp['dresseb']), 'zcyl': halcomp['zcyl1'] & (not halcomp['zcyl2']), 
    'ygclamp': halcomp['ygclamp'], 'zclamp': halcomp['zclamp'], 'fourR': halcomp['fourR'], 'test': halcomp['test'],
    'h1pressure':halcomp['H1.pressure'],'h2pressure':halcomp['H2.pressure']}

    for i in range(9):
        data = {'load': halcomp["axis.%d.load" % i], 'limit_load': halcomp["axis.%d.limit-load" % i]}
        if hasattr(halcomp, "axis.%d.srv-rpm" % i):
            data['srv-rpm'] = halcomp["axis.%d.srv-rpm" % i]
        d['hal']['axis'].append(data)

    d['homed'] = is_homed()

    return jsonify(d)


@app.route('/cnc/error')
def cnc_error():
    e = emc_error.poll()
    if not e:
        return ''
    result = {'t': e[0], 'm': e[1]}
    return jsonify(result)

def set_motion_mode():
    emc_stat.poll()
    if emc_stat.motion_mode != emc.TRAJ_MODE_TELEOP:
        emc_command.teleop_enable(1)
        emc_command.wait_complete()

homing_proc = None

def do_homing():
    def _homing():
        global homing_proc
        if ensure_mode(emc_stat, emc_command, emc.MODE_MANUAL) is False:
            return
        homing_proc = subprocess.Popen(["vcp-homing-all.sh"])
        homing_proc.communicate()
        do_homing_res = -1
        if homing_proc is not None:
            do_homing_res = homing_proc.returncode
            del homing_proc
            homing_proc = None
        if do_homing_res == 0:
            emc_command.home(-1)

    if homing_proc == None:
        t1 = threading.Thread(target=_homing)
        t1.daemon = True
        t1.start()

def stop_homing():
    global homing_proc
    if homing_proc is not None:
        homing_proc.send_signal(signal.SIGINT)

@app.route('/cnc/program/upload', methods = ['POST'])
def cnc_program_upload():
    f = request.files['program_file']
    filename = secure_filename(f.filename)
    f.save(os.path.join(program_path, filename))
    d = {'result':'ok'}
    return jsonify(d)



@app.route('/cnc/program/list')
def cnc_program_list():
    def get_list(path):
        l = []
        for f in os.listdir(path):
            filepath = os.path.join(path, f)
            st = os.stat(filepath)
            if (os.path.isdir(filepath)):
                c = {'name':f, 'fullpath':filepath, 'type':'d', 'modified':st.st_mtime, 'child':get_list(filepath)}
                l.append(c)
            else:
                l.append({'name':f, 'fullpath':filepath, 'type':'f', 'modified':st.st_mtime, 'size':st.st_size})
        return l

    d = {'result':'ok', 'list':get_list(program_path)}
    return jsonify(d)



@app.route('/cnc/program/select')
def cnc_program_select():
    f = request.args.get('filename')
    filename = f
    #filename = secure_filename(f)
    #filename = os.path.join(program_path, filename)
    emc_command.mode(emc.MODE_MDI)
    emc_command.wait_complete()
    emc_command.mode(emc.MODE_AUTO)
    emc_command.wait_complete()
    r = emc_command.program_open(filename)
    return '{result:"ok"}'



@app.route('/cnc/program/remove')
def cnc_program_remove():
    f = request.args.get('filename')
    if os.path.isfile(f):
        os.remove(f)
    return '{result:"ok"}'



@app.route('/cnc/program/view')
def cnc_program_view():
    filename = request.args.get('filename')
    #filename = secure_filename(f)
    #filename = os.path.join(program_path, filename)
    with open(filename, 'r') as content_file:
        content = content_file.read()
    d = {'result':'ok', 'data':content}
    return jsonify(d)



@app.route('/cnc/command', methods = ['POST'])
def cnc_command():
    p = request.json

    if p['command'] == 'estop':
        if p['arg']:
            stop_homing()
            emc_command.state(emc.STATE_ESTOP)
        else:
            stop_homing()
            emc_command.state(emc.STATE_ESTOP_RESET)
    elif p['command'] == 'power':
        if p['arg']:
            stop_homing()
            emc_command.mode(emc.MODE_MANUAL)
            emc_command.wait_complete()
            emc_command.state(emc.STATE_ON)
        else:
            stop_homing()
            emc_command.mode(emc.MODE_MANUAL)
            emc_command.wait_complete()
            emc_command.state(emc.STATE_OFF)
    elif p['command'] == 'run':
        emc_command.mode(emc.MODE_AUTO)
        emc_command.wait_complete()
        emc_command.auto(emc.AUTO_RUN, 1)
    elif p['command'] == 'stop':
        emc_command.abort()
        emc_command.wait_complete()
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.wait_complete()
    elif p['command'] == 'pause':
        if p['arg']:
            emc_stat.poll()
            if emc_stat.task_mode != emc.MODE_AUTO or\
                    emc_stat.interp_state not in (emc.INTERP_READING, emc.INTERP_WAITING):
                return
            ensure_mode(emc_stat, emc_command, emc.MODE_AUTO)
            emc_command.auto(emc.AUTO_PAUSE)
        else:
            emc_stat.poll()
            if not emc_stat.paused:
                return
            if emc_stat.task_mode not in (emc.MODE_AUTO, emc.MODE_MDI):
                return
            ensure_mode(emc_stat, emc_command, emc.MODE_AUTO, emc.MODE_MDI)
            emc_command.auto(emc.AUTO_RESUME)
    elif p['command'] == 'step':
        ensure_mode(emc_stat, emc_command, emc.MODE_AUTO)
        emc_command.auto(emc.AUTO_STEP)
    elif p['command'] == 'homeall':
        do_homing()
    elif p['command'] == 'unhomeall':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.unhome(-1)
    elif p['command'] == 'feedrate':
        emc_command.feedrate(float(p['arg']))
    elif p['command'] == 'spindlerate':
        emc_command.spindleoverride(float(p['arg']))
    elif p['command'] == 'maxvelocity':
        emc_command.maxvel(float(p['arg']))
    elif p['command'] == 'mist':
        emc_command.mist(1 if p['arg'] else 0)
    elif p['command'] == 'flood':
        emc_command.flood(1 if p['arg'] else 0)
    elif p['command'] == 'spindle_forward':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.spindle(1, 100)
    elif p['command'] == 'spindle_backward':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.spindle(-1, 100)
    elif p['command'] == 'spindle_stop':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.spindle(0)
    elif p['command'] == 'spindle_inc':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.spindle(emc.SPINDLE_INCREASE)
    elif p['command'] == 'spindle_dec':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.spindle(emc.SPINDLE_DECREASE)
    elif p['command'] == 'jog':
        direction = p['arg']['direction']
        axis = p['arg']['axis']
        mode_ready = ensure_mode(emc_stat, emc_command, emc.MODE_MANUAL)
        if mode_ready is True:
            if direction == 0:
                emc_command.jog(emc.JOG_STOP, axis)
            else:
                distance = p['arg']['distance']
                rate = p['arg']['rate']

                if distance == 0:
                    emc_command.jog(emc.JOG_CONTINUOUS, axis, direction * rate)
                else:
                    length = [0.001, 0.01, 0.1, 1, 10]
                    emc_command.jog(emc.JOG_INCREMENT, axis, direction * rate, length[distance - 1] * units)
    elif p['command'] == 'jog_direct':
        position = float(p['arg']['position'])
        axis = p['arg']['axis']

        emc_command.mode(emc.MODE_MANUAL)
        #set_motion_mode()
        rate = p['arg']['rate']
        emc_command.jog(emc.JOG_ABSOLUTE, axis, rate, position)
    elif p['command'] == 'shutdown':
        os.system('/sbin/shutdown -h now')
    elif p['command'] == 'reset':
        #request.environ.get('werkzeug.server.shutdown')()
        uwsgi.stop()
    elif p['command'] == 'mdi':
        emc_command.mode(emc.MODE_MDI)
        if p['arg']:
            emc_command.mdi(p['arg']['command'])
    elif p['command'] == 'blow':
        halcomp['blow'] = p['arg']
    elif p['command'] == 'vacuum':
        halcomp['vacuum'] = p['arg']
    elif p['command'] == 'touch':
        halcomp['touch'] = p['arg']
    elif p['command'] == 'dresser':
        if p['arg'] == True :
            halcomp['dresseb'] = not p['arg']
            halcomp['dressef'] = p['arg']
        elif p['arg'] == False :
            halcomp['dressef'] = p['arg']
            halcomp['dresseb'] = not p['arg']
    elif p['command'] == 'dseal':
        halcomp['dseal'] = p['arg']
    elif p['command'] == 'zcyl':
        if p['arg'] == True :
            halcomp['zcyl2'] = not p['arg']
            halcomp['zcyl1'] = p['arg']
        elif p['arg'] == False :
            halcomp['zcyl1'] = p['arg']
            halcomp['zcyl2'] = not p['arg']
    elif p['command'] == 'ygclamp':
        halcomp['ygclamp'] = p['arg']
    elif p['command'] == 'zclamp':
        halcomp['zclamp'] = p['arg']
    elif p['command'] == 'fourR':
        halcomp['fourR'] = p['arg']
    elif p['command'] == 'ygmode':
        if ini.find('EMC', 'MODE') == 'YG' :
            os.system('/home/jmac/linuxcnc/configs/mode.sh UGM060Y')
            request.environ.get('werkzeug.server.shutdown')()
        elif ini.find('EMC', 'MODE') == 'Y' :
            os.system('/home/jmac/linuxcnc/configs/mode.sh UGM060YG')
            request.environ.get('werkzeug.server.shutdown')()
        
    elif p['command'] == 'test':
        halcomp['test'] = p['arg']

    # survo on off    
    elif p['command'] == 'jog_on':
        emc_command.teleop_enable(0)
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.wait_complete()
        emc_command.set_axis_on(int(p['axis']))
    elif p['command'] == 'jog_off':
        emc_command.mode(emc.MODE_MANUAL)
        emc_command.wait_complete()
        emc_command.set_axis_off(int(p['axis']))

    elif p['command'] == 'jogdial':
        mode_ready = ensure_mode(emc_stat, emc_command, emc.MODE_MANUAL)
        if mode_ready is True:
            halcomp['jog-scale'] = float(p['arg']['scale'])
            halcomp['jog-x'] = 0
            halcomp['jog-y'] = 0
            halcomp['jog-z'] = 0
            halcomp['jog-c'] = 0
            halcomp['jog-d'] = 0
            if(p['arg']['axis']==0) : 
                halcomp['jog-x'] = 1
                if  p['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog0-wheel']
                elif p['act'] == 'wheel':
                    halcomp['jog0-wheel'] = halcomp['jog-count-latest'] + int(p['arg']['dial'])
            elif(p['arg']['axis']==1) : 
                halcomp['jog-y'] = 1
                if  p['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog1-wheel']
                elif p['act'] == 'wheel':
                    halcomp['jog1-wheel'] = halcomp['jog-count-latest'] + int(p['arg']['dial'])
            elif(p['arg']['axis']==2) : 
                halcomp['jog-z'] = 1
                if  p['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog2-wheel']
                elif p['act'] == 'wheel':
                    halcomp['jog2-wheel'] = halcomp['jog-count-latest'] + int(p['arg']['dial'])
            elif(p['arg']['axis']==3) : 
                halcomp['jog-c'] = 1
                if  p['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog3-wheel']
                elif p['act'] == 'wheel':
                    halcomp['jog3-wheel'] = halcomp['jog-count-latest'] + int(p['arg']['dial'])
            elif(p['arg']['axis']==4) : 
                halcomp['jog-d'] = 1
                if  p['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog4-wheel']
                elif p['act'] == 'wheel':
                    halcomp['jog4-wheel'] = halcomp['jog-count-latest'] + int(p['arg']['dial'])
            
    
    elif p['command'] == 'h1pressure':
        halcomp['H1.pressure'] = int(p['arg'])
    elif p['command'] == 'h2pressure':
        halcomp['H2.pressure'] = int(p['arg'])   

    return '{result:"ok"}'

@app.route('/cnc/page' )
def pageDirection():
    return page_direction

class DummyProgress:
    def nextphase(self, unused): pass
    def progress(self): pass

class StatCanon(rs274.glcanon.GLCanon, rs274.interpret.StatMixin):
    def __init__(self, colors, geometry, lathe_view_option, stat, random):
        rs274.glcanon.GLCanon.__init__(self, colors, geometry)
        rs274.interpret.StatMixin.__init__(self, stat, random)
        self.progress = DummyProgress()
        self.lathe_view_option = lathe_view_option

    def is_lathe(self): return self.lathe_view_option

    def change_tool(self, pocket):
        rs274.glcanon.GLCanon.change_tool(self,pocket)
        rs274.interpret.StatMixin.change_tool(self,pocket)

    def next_line(self, st):
        rs274.glcanon.GLCanon.next_line(self, st)

    def comment(self, arg):
        rs274.glcanon.GLCanon.comment(self, arg)

def get_geometry():
    temp = ini.find("DISPLAY", "GEOMETRY")
    if temp:
        geometry = re.split(" *(-?[XYZABCUVW])", temp.upper())
        _geometry = "".join(reversed(geometry))
    else:
        _geometry = 'XYZ'
    return _geometry

def load_preview(f, canon, unitcode, initcode, interpname=""):
    try:
        result, seq = gcode.parse(f, canon, unitcode, initcode, interpname)
    except KeyboardInterrupt:
        result, seq = 0, 0

    if result <= gcode.MIN_ERROR:
        canon.progress.nextphase(1)
        canon.calc_extents()

    return result, seq

colors = {
    'traverse': (0.30, 0.50, 0.50),
    'traverse_alpha': 1/3.,
    'traverse_xy': (0.30, 0.50, 0.50),
    'traverse_alpha_xy': 1/3.,
    'traverse_uv': (0.30, 0.50, 0.50),
    'traverse_alpha_uv': 1/3.,
    'backplotprobing_alpha': 0.75,
    'backplotprobing': (0.63, 0.13, 0.94),
    'backplottraverse': (0.30, 0.50, 0.50),
    'label_ok': (1.00, 0.51, 0.53),
    'backplotjog_alpha': 0.75,
    'tool_diffuse': (0.60, 0.60, 0.60),
    'backplotfeed': (0.75, 0.25, 0.25),
    'back': (0.00, 0.00, 0.00),
    'lathetool_alpha': 0.10,
    'axis_x': (0.20, 1.00, 0.20),
    'cone': (1.00, 1.00, 1.00),
    'cone_xy': (0.00, 1.00, 0.00),
    'cone_uv': (0.00, 0.00, 1.00),
    'axis_z': (0.20, 0.20, 1.00),
    'label_limit': (1.00, 0.21, 0.23),
    'backplotjog': (1.00, 1.00, 0.00),
    'selected': (0.00, 1.00, 1.00),
    'lathetool': (0.80, 0.80, 0.80),
    'dwell': (1.00, 0.50, 0.50),
    'overlay_foreground': (1.00, 1.00, 1.00),
    'overlay_background': (0.00, 0.00, 0.00),
    'straight_feed': (1.00, 1.00, 1.00),
    'straight_feed_alpha': 1/3.,
    'straight_feed_xy': (0.20, 1.00, 0.20),
    'straight_feed_alpha_xy': 1/3.,
    'straight_feed_uv': (0.20, 0.20, 1.00),
    'straight_feed_alpha_uv': 1/3.,
    'small_origin': (0.00, 1.00, 1.00),
    'backplottoolchange_alpha': 0.25,
    'backplottraverse_alpha': 0.25,
    'overlay_alpha': 0.75,
    'tool_ambient': (0.40, 0.40, 0.40),
    'tool_alpha': 0.20,
    'backplottoolchange': (1.00, 0.65, 0.00),
    'backplotarc': (0.75, 0.25, 0.50),
    'm1xx': (0.50, 0.50, 1.00),
    'backplotfeed_alpha': 0.75,
    'backplotarc_alpha': 0.75,
    'arc_feed': (1.00, 1.00, 1.00),
    'arc_feed_alpha': .5,
    'arc_feed_xy': (0.20, 1.00, 0.20),
    'arc_feed_alpha_xy': 1/3.,
    'arc_feed_uv': (0.20, 0.20, 1.00),
    'arc_feed_alpha_uv': 1/3.,
    'axis_y': (1.00, 0.20, 0.20),
    'grid': (0.15, 0.15, 0.15),
}

@app.route('/program/preview')
def program_preview():
    content = {'traverse':[], 'arcfeed':[], 'feed':[]}
    filename = request.args.get('filename')

    emc_stat.poll()
    lathe_option = True
    td = tempfile.mkdtemp()

    random = int(ini.find("EMCIO", "RANDOM_TOOLCHANGER") or 0)
    canon = StatCanon(colors, get_geometry(), lathe_option, emc_stat, random)
    temp_parameter = os.path.join(td, os.path.basename(parameter or "linuxcnc.var"))
    if parameter:
        shutil.copy(os.path.join(ini_dir, parameter), temp_parameter)
    unitcode = "G%d" % (20 + (emc_stat.linear_units == 1))
    initcode = ini.find("RS274NGC", "RS274NGC_STARTUP_CODE") or ""
    interpname = ini.find("TASK", "INTERPRETER") or ""
    result, seq = load_preview(filename, canon, unitcode, initcode, interpname)
    if result > gcode.MIN_ERROR:
        print(result, seq, filename)

    geometry = get_geometry()
    for line in canon.traverse:
        linuxcnc.line9(geometry, line[1], line[2])
        content['traverse'].append([line[0], line[1], line[2]])
    for line in canon.arcfeed:
        linuxcnc.line9(geometry, line[1], line[2])
        content['arcfeed'].append([line[0], line[1], line[2]])
    for line in canon.feed:
        linuxcnc.line9(geometry, line[1], line[2])
        content['feed'].append([line[0], line[1], line[2]])

    d = {'result':'ok', 'data':content}
    return jsonify(d)

@app.route('/cnc/offset', methods = ['GET'])
def get_offset():
    d_var = get_variable(parameter_path)
    if not d_var:
        return jsonify({'result': 'failed'})

    d = dict()
    g54_x_idx = 5221
    for i in range(5):
        for j in range(3):
            target_idx = g54_x_idx + (j*20) + i
            d[target_idx] = d_var[target_idx] 
    d['result'] = 'ok'
    return jsonify(d)


##################################################################################
#                                     PMAC                                        #
##################################################################################


@app.route('/pmac/stat', methods = ['GET'])
def pmac_stat():
    d = {}
    emc_stat.poll()

    pmac_online.estopped = emc_stat.task_state == emc.STATE_ESTOP
    pmac_online.machine_on = emc_stat.task_state == emc.STATE_ON
    pmac_online.running = emc_stat.task_mode != emc.MODE_MANUAL
    pmac_online.paused = emc_stat.paused
    
    for i in [
        'file', 'motion_line', 'actual_position', 'state' ,'task_state', 
        'task_mode', 'paused', 'estop', 'interp_state','homed', 'feedrate',
        'max_velocity', 'rapidrate', 'i_variable'
    ]:
        d[i] = getattr(emc_stat, i)
    d['allhomed'] = is_homed()
    d['linear_units'] = emc_stat.linear_units
    d['max_feedrate'] = max_feedrate
    d['limit_velocity'] = limit_velocity
    d['axes'] = axes
    d['program_path'] = program_path
    #d['timer'] = strftime("%Y-%m-%d %H:%M:%S")

    return jsonify(d)


@app.route('/pmac/error', methods = ['GET'])
def pmac_error():
    
    e = emc_error.poll()
    command_msg = pmac_online.read()
    time_msg = strftime("[%Y-%m-%d %H:%M:%S]")
    if e:
        error_kind, error_text = e
        if error_kind in (linuxcnc.NML_ERROR, linuxcnc.OPERATOR_ERROR):
            error_type = "Error"
        else:
            error_type = "Info"
        msg = error_text.split('\n')
        msg = [x for x in msg if x]
        err = time_msg + " %s: %s" % (error_type, msg[-1]) +'\n'
    else : err = ''
   
    return jsonify({'err' : err, 'read' : command_msg })

    
@app.route('/pmac/terminal', methods = ['POST'])
def online_command():
    p = request.json
   
    pmac_online.write(p)

    
    return jsonify({'result' : 'OK'}) 

@app.route('/pmac/program/select', methods = ['POST'])
def pmac_program_view():
    p = request.json
    
    filename = program_path + '/%s.prog' %(p)

    try : 
        f = open(filename, 'r')
        content = f.read()
        f.close()

    except IOError:
        content = ''
    return jsonify({'result' : content})

@app.route('/pmac/program/upload', methods = ['POST'])
def pmac_program_upload():
    for i in request.files :
        f = request.files[i]
        filename = '%s.prog' %(i[8:])
        f.save(os.path.join(program_path, filename))
    d = {'result' : 'ok'}

    return jsonify(d)

@app.route('/pmac/program/list')
def pmac_program_list():
    def get_prog(path):
        l = []
        for num in range(1, 21) :
            f = '%s.prog' %num
            
            try :
                filepath = os.path.join(path, f)
                st = os.stat(filepath)
                name = open(filepath,'r')
                l.append({'name':name.readline(), 'modified':st.st_mtime*1000, 'size':st.st_size})
                name.close()
            except :
                l.append({'name':'no_file','modified':'', 'size':''})
        return l

    d = {'result':'ok', 'list':get_prog(program_path)}
    return jsonify(d)
    
@app.route('/pmac/axis', methods = ['POST'])
def axis_definition():
    p = request.json
    axis = ''
    
    for i, cor in enumerate(['x', 'y', 'z', '']):
        if p[i+1] in ['', '0', '0.0', '0.00', '0.000']:
            pass
        else:
            if p[i+1][0] != '-':
                axis += '+' + '%s' %p[i+1] + cor
            else:
                axis += '%s' %p[i+1] + cor 
    pmac_online.write('#%s->%s' %(p[0], axis))

    return jsonify({'result' : 'OK'}) 
    

@app.route('/pmac/buttons', methods = ['POST'])
def button_clicked():
    p = request.json
    cmd = p['command']
    try :
        arg = p['arg']
    except : 
        arg = None

    if cmd == 'estop':
        stop_homing()
        pmac_online.write('ERESET' if pmac_online.estopped else 'ESTOP')
    elif cmd == 'power':
        stop_homing()
        pmac_online.write('KK' if pmac_online.machine_on else '$$')
    elif cmd == 'homeall':
        ensure_mode(emc_stat, emc_command, emc.MODE_MANUAL)
        pmac_online.write('HOMEALL')
    elif cmd == 'unhomeall':
        pmac_online('UNHOMEALL')
    elif cmd == 'run':
        emc_command.mode(emc.MODE_AUTO)
        emc_command.wait_complete()
        pmac_online.write('R')
    elif cmd == 'stop':
        emc_command.abort()
        emc_command.wait_complete()
        emc_command.mode(emc.MODE_MANUAL)
        pmac_online.write('A')
    elif cmd == 'pause':
        if arg:
            emc_stat.poll()
            if emc_stat.task_mode != emc.MODE_AUTO or\
                    emc_stat.interp_state not in (emc.INTERP_READING, emc.INTERP_WAITING):
                return
            ensure_mode(emc_stat, emc_command, emc.MODE_AUTO)
            pmac_online.write('Q')
        else:
            emc_stat.poll()
            if not emc_stat.paused:
                return
            if emc_stat.task_mode not in (emc.MODE_AUTO, emc.MODE_MDI):
                return
            ensure_mode(emc_stat, emc_command, emc.MODE_AUTO, emc.MODE_MDI)
            pmac_online.write('R')
    elif cmd == 'step':
        ensure_mode(emc_stat, emc_command, emc.MODE_AUTO)
        pmac_online.write('S')
    elif cmd[:7] == 'program':
        pmac_online.write('B' + cmd[7:])
    elif cmd == 'jog':
        if arg['direction'] == 0 :
            pmac_online.write('J/')
        elif arg['direction'] == 1:
            pmac_online.write('#%sJ+' %(arg['m']))
        elif arg['direction'] == -1:
            pmac_online.write('#%sJ-' %(arg['m']))
    elif cmd == 'jspeed':
        pmac_online.write('I'+arg['m'] +'22 = ' + arg['vel'])
    elif cmd == 'feedrate':
        pmac_online.write('%' + arg)  
    elif cmd == 'maxvelocity':
        pmac_online.write('^' + arg)  
    elif cmd[:6] == 'homing':
        pmac_online.write('#%sHMZ' %cmd[6:])
    elif cmd[:8] == 'unhoming':
        pmac_online.write('#%sUNHMZ' %cmd[8:])
    elif cmd == 'jogTo' :
        position = float(arg['position'])
        motor = arg['m']
        emc_command.mode(emc.MODE_MANUAL)
        rate = arg['rate']
        emc_command.jog(emc.JOG_ABSOLUTE, motor, rate, position)

    elif p['command'] == 'jogdial':
        mode_ready = ensure_mode(emc_stat, emc_command, emc.MODE_MANUAL)
        if mode_ready is True:
            halcomp['jog-scale'] = float(arg['scale'])
            halcomp['jog-x'] = 0
            halcomp['jog-y'] = 0
            halcomp['jog-z'] = 0
            halcomp['jog-c'] = 0
            halcomp['jog-d'] = 0
            if(arg['axis']==0) : 
                halcomp['jog-x'] = 1
                if  arg['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog0-wheel']
                elif arg['act'] == 'wheel':
                    halcomp['jog0-wheel'] = halcomp['jog-count-latest'] + int(arg['dial'])
            elif(arg['axis']==1) : 
                halcomp['jog-y'] = 1
                if  arg['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog1-wheel']
                elif arg['act'] == 'wheel':
                    halcomp['jog1-wheel'] = halcomp['jog-count-latest'] + int(arg['dial'])
            elif(arg['axis']==2) : 
                halcomp['jog-z'] = 1
                if  arg['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog2-wheel']
                elif arg['act'] == 'wheel':
                    halcomp['jog2-wheel'] = halcomp['jog-count-latest'] + int(arg['dial'])
            elif(arg['axis']==3) : 
                halcomp['jog-c'] = 1
                if  arg['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog3-wheel']
                elif arg['act'] == 'wheel':
                    halcomp['jog3-wheel'] = halcomp['jog-count-latest'] + int(arg['dial'])
            elif(arg['axis']==4) : 
                halcomp['jog-d'] = 1
                if  arg['act'] == 'set':
                    halcomp['jog-count-latest'] = halcomp['jog4-wheel']
                elif arg['act'] == 'wheel':
                    halcomp['jog4-wheel'] = halcomp['jog-count-latest'] + int(arg['dial'])

    return jsonify({'result' : 'OK'})

@app.route('/lms/init/mode', methods = ['GET'])
def mode_download():
    # ret = ini.find('DISPLAY', 'WEBUI_PLOT')
    #FIXME LMS-webd only run on monitoring mode temporary 
    return jsonify({'mode' : 'monitoring'})

@app.route('/lms/mover_position', methods = ['GET'])
def position_pass():
    emc_stat.poll()
    print(emc_stat.position)

    return jsonify({'positions': emc_stat.position})

@app.route('/lms/init/topology', methods = ['GET'])
def topology_download():
    # FIXME 
    d={}
    tpg = elemTree.parse(ini_dir + '/lms.xml')

    tpgGlobal = tpg.find('./Global')
    tpgLength = tpgGlobal.find('./Length')

    coilLength = tpgLength.get('coil')
    moverLength = tpgLength.get('mover')

    elevators, tracks = [], {}
    tpgLocal = tpg.find('./Local')

    # sort coils as asccending track_id and get track_ids
    print(tpgLocal.findall('.Coil'))
    return jsonify({'coils': tpgLocal.findall('.Coil')})

    # insert all coils in tracks or elevator
    # insert all carriers in tracks
    """
    for coil in tpgLocal.findall('./Coil'):
        coil_type = coil.get('type')
        coil_track = coil.get('track')

        if coil_type == '0':
            # coil in track
            if coil_track in tracks:
                tracks[coil_track][coils].append({
                })
            else:
                tracks[coil_track] = {
                    'id': coil_track,
                    'begin': 0 ,
                    'end': 0,
                    'height': 0,
                    'coils': [],
                    'carriers': []
                }
        else:
            # coil in elevator 
            tpg_tmp['type'] = 'elevator'
            tpg_tmp['offset2'] = coil.get('offset2')

        tpg_tmp['track'] = coil.get('track')
        tpg_tmp['offset'] = coil.get('offset')
        d['Local']['Coil'].append(copy.deepcopy(tpg_tmp))
        tpg_tmp = {}
    
    return jsonify(d)
    """

##################################################################################
#                                   EtherCAT                                     #
##################################################################################



@app.route('/ethercat')
def ethercat_index():
    return render_template('ethercat.html')


@app.route('/ethercat/result', methods = ['POST'])
def result():
    if xmlfile == '' or halfile == '':
        return jsonify({'result' : 'EtherCAT xml or hal file was not found'})
        
    app_time_period = ini.find('EMCMOT', 'BASE_PERIOD')
    if not app_time_period:
        app_time_period = ini.find('EMCMOT', 'SERVO_PERIOD')
    
    a = apply(request.json, app_time_period, xmlfile, halfile)
    return jsonify({'result' : a})

@app.route('/ethercat/data/p', methods = ['GET'])
def ethercat_json_p():
  
    p = ethercat_config.getEtherCATData(xmlfile)
    return jsonify({'result' : p})


@app.route('/ethercat/data/ap', methods = ['GET'])
def ethercat_json_ap():

    ap = ethercat_config.getAperiodicData(xmlfile)
    return jsonify({'result' : ap})


@app.route('/ethercat/subdata/', methods = ['GET'])
def ethercat_subdata():
    return jsonify({'result' : axes_list})       
    

@app.route('/ethercat/topology', methods = ['GET'])
def ethercat_topology():
    try : 
        data = open(topology_path).read()
        return data

    except IOError:
        return ''

@app.route('/ethercat/command', methods = ['POST'])
def ethercat_command():
    
    p = request.json
    

    if p['command'] == 'rescan' :
        ethercat_config.rescan()
    elif p['command'] == 'masterCtl' :
        if p['buttonName'] == 'Init' : 
            ethercat_config.state(65535, 1)
        elif p['buttonName'] == 'PreOP':
            ethercat_config.state(65535, 2)
        elif p['buttonName'] == 'SafeOP':
            ethercat_config.state(65535, 4)
        elif p['buttonName'] == 'OP':
            ethercat_config.state(65535, 8)    
    elif p['command'] == 'slaveCtl' :
        if p['buttonName'] == 'Init' : 
            ethercat_config.state(int(p['slaveNum']), 1)
        elif p['buttonName'] == 'PreOP':
            ethercat_config.state(int(p['slaveNum']), 2)
        elif p['buttonName'] == 'SafeOP':
            ethercat_config.state(int(p['slaveNum']), 4)
        elif p['buttonName'] == 'OP': 
            ethercat_config.state(int(p['slaveNum']), 8)
    elif p['command'] == 'sdo' :
        if p['subCommand'] == 'upload' :
            upload_return = ethercat_config.sdoUpload(int(p['slaveNum']),c_ushort(p['index']).value,c_ubyte(p['subindex']).value,p['type'].encode('ascii'))
            
            return jsonify({'result' : "upload", 'upload_return' : upload_return})

        elif p['subCommand'] == 'download' :
	    		
            download_return = ethercat_config.sdoDownload(int(p['slaveNum']),int(p['index']),int(p['subindex']),p['type'].encode('ascii'),p['value'].encode('ascii'))
            return jsonify({'result' : "upload", 'upload_return' : download_return})
    elif p['command'] == 'pageMove' :
        global page_direction
        page_direction = p['direction']

    return jsonify({'result' : "ok"})




def main():
    app.config['TEMPLATES_AUTO_RELOAD'] = True
    app.run(host='0.0.0.0', threaded=True, debug=False)

if __name__ == '__main__':
    main()
